#!/usr/bin/python
#-*- coding: utf-8 -*-

# =========================================================================
#   Program:   iota2
#
#   Copyright (c) CESBIO. All rights reserved.
#
#   See LICENSE for details.
#
#   This software is distributed WITHOUT ANY WARRANTY; without even
#   the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#   PURPOSE.  See the above copyright notices for more information.
#
# =========================================================================

import os
import sys
import unicodedata
from collections import Counter, defaultdict
import csv
import numpy as np
from pandas import MultiIndex, DataFrame
import codecs
import createSymbologyQGIS as csq
from Common import FileUtils as fu


def convertHextoRGB(color):
    
    h=color.lstrip('#')
    return tuple(int(h[i:i+2], 16) for i in (0, 2 ,4))    

def convertRGBtoHEX(rgb):
    
    return '#%02x%02x%02x'%(rgb)

def get_unique(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]

def getNomenclature(qml, outpath):
    
    classes = csq.getClassesFromQML(qml)
    out = [[x[0], x[1], convertRGBtoHEX(tuple(x[2])), "".join(unicodedata.normalize('NFKD', x[0][0:11].decode("utf-8", "ignore")).encode('ascii','ignore').split())] for x in classes]

    for line in out:
        line[3] = ''.join(e for e in line[3] if e.isalnum())
    
    with open(outpath, 'w') as f:
        writer = csv.writer(f)        
        writer.writerows(out)
        
    duplicates = [item for item, count in Counter([x[3] for x in out]).items() if count > 1]
    if len(duplicates) != 0:
        print "Automatic procedure generated duplicates of Alias, please change manually aliases of the nomenclature file"
    else:
        print "Please, check aliases in the nomenclature file automatically generated by this procedure"

        
class iota_nomenclature(object):
    
    def __init__(self, nomenclature):
        
        self.nomenclature = nomenclature
        self.level = self.getLevelNumber()
        self.getMaxLevelClassNb = self.getMaxLevelClassNb()
        self.HierarchicalNomenclature = self.setHierarchicalNomenclature(self.nomenclature)
        
    def getLevelNumber(self):
        
        classeslist = self.readNomenclatureFile(self.nomenclature)
        levels = len(classeslist[0]) / 4
        
        return levels

    def getMaxLevelClassNb(self):
        
        classeslist = self.readNomenclatureFile(self.nomenclature)
        return len(classeslist)

    def getColor(self, level, typec = "RGB"):
        
        if level <= self.getLevelNumber() and level > 0:
            index = self.setHierarchicalNomenclature(self.nomenclature)
            if typec == "RGB":
                if '#' in list(index.get_level_values(level - 1))[0][2]:                
                    return get_unique([(convertHextoRGB(x[2])) for x in list(index.get_level_values(level - 1))])
                else:
                    raise Exception("Color already in RGB format or in unknown format")
            elif typec == "HEX":
                return get_unique([x[2] for x in list(index.get_level_values(level - 1))])
            else:
                raise Exception("Unknown color format provided")                
        else:
            raise Exception("Level %s does not exists"%(level))

    def getClass(self, level):
        
        if level <= self.getLevelNumber() and level > 0:
            index = self.setHierarchicalNomenclature(self.nomenclature)
            return get_unique([x[0] for x in list(index.get_level_values(level - 1))])
        else:
            raise Exception("Level %s does not exists"%(level))

    def getAlias(self, level):
        
        if level <= self.getLevelNumber() and level > 0:
            index = self.setHierarchicalNomenclature(self.nomenclature)
            return get_unique([x[3] for x in list(index.get_level_values(level - 1))])
        else:
            raise Exception("Level %s does not exists"%(level))
        
    def getCode(self, level):
        
        if level <= self.getLevelNumber() and level > 0:
            index = self.setHierarchicalNomenclature(self.nomenclature)
            return get_unique([int(x[1]) for x in list(index.get_level_values(level - 1))])
        else:
            raise Exception("Level %s does not exists"%(level))
            
    def setHierarchicalNomenclature(self, nomen):

        classeslist = []
        levelname = []
        rawclasses = self.readNomenclatureFile(nomen)
        
        for ind, line in enumerate(rawclasses):
            classeslist.append([])
            for lev in range(self.level):
                if len(levelname) < self.level:
                    levelname.append("level%s"%(lev + 1))
                
                classeslist[ind].append((line[4 * lev], line[(4 * lev) + 1], line[(4 * lev) + 2], line[(4 * lev) + 3]))

        index = MultiIndex.from_tuples([tuple(x) for x in classeslist], names=levelname)

        return index
    
    def readNomenclatureFile(self, nomen):
        
        fileclasses = codecs.open(nomen, "r", "utf-8")
        rawclasses = [tuple(line.rstrip('\n').split(',')) for line in fileclasses.readlines()]
        
        return rawclasses

    def createNomenclatureQML(self, level, outpath, codefield, filetype = "raster", outlinestyle = "", nodata = ""):
        if len(self.getClass(level)) == len(self.getColor(level)):
            colorRGBlist = [[x[0], x[1], str(x[2][0]), str(x[2][1]), str(x[2][2]), x[3]] for x in zip(self.getCode(level), \
                                                                                                      self.getClass(level), \
                                                                                                      self.getColor(level), \
                                                                                                      self.getColor(level, "HEX"))]
            if filetype == "raster":                
                csq.createRasterQML(colorRGBlist, outpath, codefield, nodata)
            elif filetype == "vector":                
                csq.createVectorQML(colorRGBlist, outpath, codefield, outlinestyle)
            else:
                raise Exception("unknown option for output type of qml file (valid values : 'raster' or 'vector')")
        else:
            raise Exception("Duplicates colors or classes found in the nomenclature file")

    def createConfusionMatrix(self, otbmatrix):

        mat = fu.confCoordinatesCSV(otbmatrix)
	d = defaultdict(list)
	for k,v in mat:
		d[k].append(v)
	csv_f = list(d.items())
        
        # get matrix from csv
        matrix = fu.gen_confusionMatrix(otbmatrix, self.getCode(self.level))        

        # MultiIndex Pandas dataframe
        cmdf = DataFrame(matrix, index = self.HierarchicalNomenclature, columns = self.HierarchicalNomenclature)

        return cmdf
        
        
#openClasses("/home/qt/thierionv/iota2/iota2/data/references/classes_iota23")

iota=iota_nomenclature("/home/qt/thierionv/iota2/iota2/data/references/classes_iota23")
print iota.createConfusionMatrix(["/work/OT/theia/oso/production/cnes/test/FRANCE_2016/final/TMP/Classif_Seed_0.csv"])
#print iota.HierarchicalNomenclature
#print iota.getMaxLevelClassNb()
#print iota.HierarchicalNomenclature
#print iota.getColor(2)
#print iota.getAlias(2)
#print iota.createNomenclatureQML(2, "/home/qt/thierionv/testraster.qml", "code", "raster", "no", "0")
#print iota.getCode(2)
#getNomenclature("/home/qt/thierionv/testvector.qml", "/home/qt/thierionv/nomenclaturetest")
