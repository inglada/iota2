#!/usr/bin/python
#-*- coding: utf-8 -*-

# =========================================================================
#   Program:   iota2
#
#   Copyright (c) CESBIO. All rights reserved.
#
#   See LICENSE for details.
#
#   This software is distributed WITHOUT ANY WARRANTY; without even
#   the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#   PURPOSE.  See the above copyright notices for more information.
#
# =========================================================================

import os
import sys
import unicodedata
from collections import Counter, defaultdict
import csv
import numpy as np
from pandas import MultiIndex, DataFrame
import codecs
import createSymbologyQGIS as csq
from Common import FileUtils as fu


def convertHextoRGB(color):
    
    h=color.lstrip('#')
    return tuple(int(h[i:i+2], 16) for i in (0, 2 ,4))    

def convertRGBtoHEX(rgb):
    
    return '#%02x%02x%02x'%(rgb)

def get_unique(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]

def getNomenclature(qml, outpath):
    
    classes = csq.getClassesFromQML(qml)
    out = [[x[0], x[1], convertRGBtoHEX(tuple(x[2])), "".join(unicodedata.normalize('NFKD', x[0][0:11].decode("utf-8", "ignore")).encode('ascii','ignore').split())] for x in classes]

    for line in out:
        line[3] = ''.join(e for e in line[3] if e.isalnum())
    
    with open(outpath, 'w') as f:
        writer = csv.writer(f)        
        writer.writerows(out)
        
    duplicates = [item for item, count in Counter([x[3] for x in out]).items() if count > 1]
    if len(duplicates) != 0:
        print("Automatic procedure generated duplicates of Alias, please change manually aliases of the nomenclature file")
    else:
        print("Please, check aliases in the nomenclature file automatically generated by this procedure")

        
class iota_nomenclature(object):
    """
    Class for manipulating multi-level nomenclature :
    - extract specific attributes (code, name, alias, color) on a specfic level
    - prepare multi-level confusion matrix (OTB style)
    - prepare QGIS layer style (QML)
    - extract nomenclature from QML file
    """

    def __init__(self, nomenclature):
        
        self.nomenclature = nomenclature
        self.level = self.getLevelNumber()
        self.getMaxLevelClassNb = self.getMaxLevelClassNb()
        self.HierarchicalNomenclature = self.setHierarchicalNomenclature(self.nomenclature)

    def __repr__(self):
        
        return 'Nomenclature : %s level(s) with %s classes for the last level'%(self.getLevelNumber(), self.getMaxLevelClassNb)
    
    def getLevelNumber(self):
        """
        get the number of levels of a nomenclature
        """        
        classeslist = self.readNomenclatureFile(self.nomenclature)
        levels = len(classeslist[0]) / 4
        
        return levels

    def getMaxLevelClassNb(self):
        """
        get number of classes corresponding to lower level (more detailed) : level for classification purpose 
        """
        
        classeslist = self.readNomenclatureFile(self.nomenclature)
        return len(classeslist)

    def getColor(self, level, typec = "RGB"):
        """
        get colors list of given level

        :param level: level of the nomenclature
        :type level: int
        :param typec: format of input colors (HEX / RGB)
        :type typec: str

        """        
        if level <= self.getLevelNumber() and level > 0:
            index = self.setHierarchicalNomenclature(self.nomenclature)
            if typec == "RGB":
                if '#' in list(index.get_level_values(level - 1))[0][2]:                
                    return get_unique([(convertHextoRGB(x[2])) for x in list(index.get_level_values(level - 1))])
                else:
                    raise Exception("Color already in RGB format or in unknown format")
            elif typec == "HEX":
                return get_unique([x[2] for x in list(index.get_level_values(level - 1))])
            else:
                raise Exception("Unknown color format provided")                
        else:
            raise Exception("Level %s does not exists"%(level))

    def getClass(self, level):
        """
        get classes list of given level

        :param level: level of the nomenclature
        :type level: int

        """
        
        if level <= self.getLevelNumber() and level > 0:
            index = self.setHierarchicalNomenclature(self.nomenclature)
            return get_unique([x[0] for x in list(index.get_level_values(level - 1))])
        else:
            raise Exception("Level %s does not exists"%(level))

    def getAlias(self, level):
        """
        get alias list of given level

        :param level: level of the nomenclature
        :type level: int

        """

        if level <= self.getLevelNumber() and level > 0:
            index = self.setHierarchicalNomenclature(self.nomenclature)
            return get_unique([x[3] for x in list(index.get_level_values(level - 1))])
        else:
            raise Exception("Level %s does not exists"%(level))
        
    def getCode(self, level):
        """
        get codes list of given level

        :param level: level of the nomenclature
        :type level: int

        """
        
        if level <= self.getLevelNumber() and level > 0:
            index = self.setHierarchicalNomenclature(self.nomenclature)
            return get_unique([int(x[1]) for x in list(index.get_level_values(level - 1))])
        else:
            raise Exception("Level %s does not exists"%(level))
            
    def setHierarchicalNomenclature(self, nomen):
        """
        set a multi-level pandas nomenclature

        :param  nomen: level of the nomenclature
        :type level: csv file

        """
        
        classeslist = []
        levelname = []
        rawclasses = self.readNomenclatureFile(nomen)
        
        for ind, line in enumerate(rawclasses):
            classeslist.append([])
            for lev in range(self.level):
                if len(levelname) < self.level:
                    levelname.append("level%s"%(lev + 1))
                
                classeslist[ind].append((line[4 * lev], line[(4 * lev) + 1], line[(4 * lev) + 2], line[(4 * lev) + 3]))

        index = MultiIndex.from_tuples([tuple(x) for x in classeslist], names=levelname)

        return index
    
    def readNomenclatureFile(self, nomen):
        """
        read a csv nomenclature file

        :param  nomen: level of the nomenclature
        :type level: csv file

        :Example:
        csv structure for 2 nested levels (l1 = level 1, l2 = level 2) :
        classname_l1, code_l1, colour_l1, alias_l1, classname_l2, code_l2, colour_l2, alias_l2
        
        """
        
        fileclasses = codecs.open(nomen, "r", "utf-8")
        rawclasses = [tuple(line.rstrip('\n').split(',')) for line in fileclasses.readlines()]
        
        return rawclasses

    def createNomenclatureQML(self, level, outpath, codefield, filetype = "raster", outlinestyle = "", nodata = ""):
        """
        create a QGIS QML layer style (raster or vector)

        :param level: level of the nomenclature
        :type level: int
        :param outpath: QML file path
        :type outpath: str
        :param codefield: field name of the classification
        :type codefield: str
        :param filetype: QML file for vector or raster ?
        :type filetype: str
        :param outlinestyle: with or without outlines of polygon
        :type outlinestyle: str
        :param nodata: No data value for raster QML style
        :type nodata: float

        :return: vector or raster QML style file
        :rtype: QML file
        """
        
        if len(self.getClass(level)) == len(self.getColor(level)):
            colorRGBlist = [[x[0], x[1], str(x[2][0]), str(x[2][1]), str(x[2][2]), x[3]] for x in zip(self.getCode(level), \
                                                                                                      self.getClass(level), \
                                                                                                      self.getColor(level), \
                                                                                                      self.getColor(level, "HEX"))]
            if filetype == "raster":                
                csq.createRasterQML(colorRGBlist, outpath, codefield, nodata)
            elif filetype == "vector":                
                csq.createVectorQML(colorRGBlist, outpath, codefield, outlinestyle)
            else:
                raise Exception("unknown option for output type of qml file (valid values : 'raster' or 'vector')")
        else:
            raise Exception("Duplicates colors or classes found in the nomenclature file")

    def createConfusionMatrix(self, otbmatrix):
        """
        create a multi-level confusion matrix (pandas DataFrame)

 
        :param otbmatric: an OTB confusionMatrix file
        :type otbmatric: csv file
        :return: multi-level confusion matrix
        :rtype: pandas.core.frame.DataFrame

        """
        
        mat = fu.confCoordinatesCSV(otbmatrix)
        d = defaultdict(list)
        for k,v in mat:
            d[k].append(v)
        csv_f = list(d.items())
        
        # get matrix from csv
        matrix = fu.gen_confusionMatrix(otbmatrix, self.getCode(self.level))        

        # MultiIndex Pandas dataframe
        cmdf = DataFrame(matrix, index = self.HierarchicalNomenclature, columns = self.HierarchicalNomenclature)

        return cmdf
        
        
#openClasses("/home/qt/thierionv/iota2/iota2/data/references/classes_iota23")

iota=iota_nomenclature("/home/qt/thierionv/iota2/iota2/data/references/classes_iota23")
print iota
#print(iota.createConfusionMatrix(["/work/OT/theia/oso/production/cnes/test/FRANCE_2016/final/TMP/Classif_Seed_0.csv"]))
#print iota.HierarchicalNomenclature
#print iota.getMaxLevelClassNb()
#print iota.HierarchicalNomenclature
#print iota.getColor(2)
#print iota.getAlias(2)
#print iota.createNomenclatureQML(2, "/home/qt/thierionv/testraster.qml", "code", "raster", "no", "0")
#print iota.getCode(2)
#getNomenclature("/home/qt/thierionv/testvector.qml", "/home/qt/thierionv/nomenclaturetest")
